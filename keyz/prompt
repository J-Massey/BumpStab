Design Document: Scientific Python Package for 3D Flow Field Analysis
Overview:

The package aims to process and analyze 3D flow fields of floats with dimensions nx, ny, nt. The package will provide functionalities for preprocessing, SPOD, DMD, Resolvent calculations, and plotting results.

1. Preprocessing:
1.1. Data Loading:

    Function Name: load_data
    Input: Path to the data file.
    Output: 3D flow field data.
    Description: This function will read in the 3D flow field data.

1.2. Subtract Mean Flow Field:

    Function Name: subtract_mean
    Input: 3D flow field data.
    Output: Mean subtracted flow field data.
    Description: Subtract the mean flow field from each time step.

1.3. Singular Value Decomposition (SVD):

    Function Name: calculate_svd
    Input: Mean subtracted flow field data.
    Output: SVD of the mean subtracted flow field.
    Description: Compute the SVD of the data.

1.4. Save Data:

    Function Name: save_hdf5
    Input: Data to be saved, filename.
    Output: None.
    Description: Save the flow fields (u,v,p) and SVD in the hdf5 format.

2. Spectral Proper Orthogonal Decomposition (SPOD):
2.1. Load Data:

    Function Name: load_hdf5
    Input: Path to the hdf5 file.
    Output: Data from the hdf5 file.
    Description: Load the data for further processing.

2.2. Calculate SPOD Modes:

    Function Name: calculate_spod
    Input: Data from hdf5 file.
    Output: SPOD modes.
    Description: Use PySPOD to calculate the SPOD modes.

2.3. Save SPOD Modes:

    Function Name: save_spod_hdf5
    Input: SPOD modes, filename.
    Output: None.
    Description: Save the SPOD modes and singular values in the hdf5 format.

3. Dynamic Mode Decomposition (DMD):
3.1. Load SVD:

    Function Name: load_svd_hdf5
    Input: Path to the hdf5 file.
    Output: SVD data.
    Description: Load the SVD for DMD calculations.

3.2. Calculate DMD Modes:

    Function Name: calculate_dmd
    Input: SVD data.
    Output: DMD modes.
    Description: Compute the DMD modes.

3.3. Calculate DMD Eigenvalues:

    Function Name: calculate_dmd_eigenvalues
    Input: DMD modes.
    Output: DMD eigenvalues.
    Description: Compute the DMD eigenvalues.

3.4. Save DMD Modes:

    Function Name: save_dmd_hdf5
    Input: DMD modes, filename.
    Output: None.
    Description: Save the DMD modes and singular values in the hdf5 format.

4. Resolvent:
4.1. Load DMD Modes:

    Function Name: load_dmd_hdf5
    Input: Path to the hdf5 file.
    Output: DMD modes and singular values.
    Description: Load the DMD modes for resolvent calculations.

4.2. Calculate Resolvent Gain:

    Function Name: calculate_resolvent_gain
    Input: DMD modes, singular values.
    Output: Resolvent gain.
    Description: Calculate the resolvent gain by looping over a range of angular frequencies.

4.3. Save Peaks in Resolvent Gain:

    Function Name: save_resolvent_peaks
    Input: Peaks in resolvent gain, filename.
    Output: None.
    Description: Save the peaks in resolvent gain.

5. Plotting:
5.1. Plot DMD Modes:

    Function Name: plot_dmd_modes
    Input: DMD modes.
    Output: Plot.
    Description: Visualize the DMD modes.

5.2. Plot Singular Values:

    Function Name: plot_singular_values
    Input: Singular values.
    Output: Plot.
    Description: Visualize the singular values.

5.3. Plot Peaks in Resolvent Gain:

    Function Name: plot_resolvent_peaks
    Input: Peaks in resolvent gain.
    Output: Plot.
    Description: Visualize the peaks in resolvent gain.

5.4. Compute and Plot Resolvent Modes:

    Function Name: plot_resolvent_modes
    Input: Resolvent modes.
    Output: Plot.
    Description: Compute and visualize the forcing and response resolvent modes.

Requirements:

    Testing: Implement unit tests for all functions using low-dimensional toy data.
    Installation: The package should be packaged and uploaded to PyPI, allowing users to install it using pip.
    Usability: The package should be designed in a way that it can be:
        Imported and used in a python script.
        Imported and used in a Jupyter notebook.
        Imported and used in a python interactive session.

Additional Notes:

    Consider using a version control system like Git to manage the codebase.
    Ensure that the package has a clear README with installation instructions and usage examples.
    Continuous integration can be set up to automatically run tests whenever changes are made to the codebase.

This design document provides a high-level overview of the functionalities and structure of the scientific python package. The actual implementation may require more detailed specifications and considerations.